<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>了不起的node.js学习笔记 | libchaos Blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="chapter 2 JavaScript概览介绍  js是基于原型,面向对象， 弱类型的的动态脚本语言。
Javascript基础
类型：

基本类型包括number, boolean, string, null 及 undefined
复杂类型包括array, function 及 object
12345678910var a = 5;var b = 5;b = a;a; // =&amp;gt; 5">
<meta property="og:type" content="article">
<meta property="og:title" content="了不起的node.js学习笔记">
<meta property="og:url" content="http://yoursite.com/2015/09/24/了不起的node.js学习笔记/index.html">
<meta property="og:site_name" content="libchaos Blog">
<meta property="og:description" content="chapter 2 JavaScript概览介绍  js是基于原型,面向对象， 弱类型的的动态脚本语言。
Javascript基础
类型：

基本类型包括number, boolean, string, null 及 undefined
复杂类型包括array, function 及 object
12345678910var a = 5;var b = 5;b = a;a; // =&amp;gt; 5">
<meta property="og:image" content="http://upload-images.jianshu.io/upload_images/891491-b095e4c9e1d0083f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
<meta property="og:updated_time" content="2015-10-08T02:39:56.000Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="了不起的node.js学习笔记">
<meta name="twitter:description" content="chapter 2 JavaScript概览介绍  js是基于原型,面向对象， 弱类型的的动态脚本语言。
Javascript基础
类型：

基本类型包括number, boolean, string, null 及 undefined
复杂类型包括array, function 及 object
12345678910var a = 5;var b = 5;b = a;a; // =&amp;gt; 5">
<meta name="twitter:image" content="http://upload-images.jianshu.io/upload_images/891491-b095e4c9e1d0083f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240">
  
    <link rel="alternative" href="/atom.xml" title="libchaos Blog" type="application/atom+xml">
  
  
    <link rel="icon" href="http://7xojpa.com1.z0.glb.clouddn.com/blog.ico">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
<body>
  <div id="container">
    <div class="left-col">
    <div class="overlay"></div>
<div class="intrude-less">
	<header id="header" class="inner">
		<a href="/" class="profilepic">
			<img src="http://7xojpa.com1.z0.glb.clouddn.com/portrait.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
		</a>

		<hgroup>
		  <h1 class="header-author"><a href="/">libchaos</a></h1>
		</hgroup>

		
		<p class="header-subtitle">Fake it</p>
		

		
			<div class="switch-btn">
				<div class="icon">
					<div class="icon-ctn">
						<div class="icon-wrap icon-house" data-idx="0">
							<div class="birdhouse"></div>
							<div class="birdhouse_holes"></div>
						</div>
						<div class="icon-wrap icon-ribbon hide" data-idx="1">
							<div class="ribbon"></div>
						</div>
						
						
					</div>

				</div>
				<div class="tips-box hide">
					<div class="tips-arrow"></div>
					<ul class="tips-inner">
						<li>菜单</li>
						<li>标签</li>
						
						
					</ul>
				</div>
			</div>
		

		<div class="switch-area">
			<div class="switch-wrap">
				<section class="switch-part switch-part1">
					<nav class="header-menu">
						<ul>
						
							<li><a href="/">主页</a></li>
				        
							<li><a href="/archives">所有文章</a></li>
				        
							<li><a href="/tags/随笔">随笔</a></li>
				        
						</ul>
					</nav>
					<nav class="header-nav">
						<div class="social">
							
								<a class="github" target="_blank" href="https://github.com/libchaos" title="github">github</a>
					        
						</div>
					</nav>
				</section>

				
				<section class="switch-part switch-part2">
					<div class="widget tagcloud" id="js-tagcloud">
						<a href="/tags/阻塞-非阻塞-IO/" style="font-size: 10px;">阻塞 非阻塞 IO</a>
					</div>
				</section>
				

				

				
			</div>
		</div>
	</header>
</div>

    </div>
    <div class="mid-col">
      <nav id="mobile-nav">
  	<div class="overlay">
  		<h1 class="header-author js-mobile-header hide">libchaos</h1>
  	</div>
	<div class="intrude-less">
		<header id="header" class="inner">
			<div class="profilepic">
				<img src="http://7xojpa.com1.z0.glb.clouddn.com/portrait.jpg" class="js-avatar" style="width: 100%;height: 100%;opacity: 1;">
			</div>
			<hgroup>
			  <h1 class="header-author">libchaos</h1>
			</hgroup>
			
			<p class="header-subtitle">Fake it</p>
			
			<nav class="header-menu">
				<ul>
				
					<li><a href="/">主页</a></li>
		        
					<li><a href="/archives">所有文章</a></li>
		        
					<li><a href="/tags/随笔">随笔</a></li>
		        
		        <div class="clearfix"></div>
				</ul>
			</nav>
			<nav class="header-nav">
				<div class="social">
					
						<a class="github" target="_blank" href="https://github.com/libchaos" title="github">github</a>
			        
				</div>
			</nav>
		</header>
	</div>
</nav>

      <div class="body-wrap"><article id="post-了不起的node.js学习笔记" class="article article-type-post" itemscope itemprop="blogPost">
  
    <div class="article-meta">
      <a href="/2015/09/24/了不起的node.js学习笔记/" class="article-date">
  	<time datetime="2015-09-24T02:21:17.000Z" itemprop="datePublished">2015-09-24</time>
</a>
    </div>
  
  <div class="article-inner">
    
      <input type="hidden" class="isFancy" />
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      了不起的node.js学习笔记
    </h1>
  

      </header>
      
      <div class="article-info article-info-post">
        
        

        <div class="clearfix"></div>
      </div>
      
    
    <div class="article-entry" itemprop="articleBody">
      
        <h3 id="chapter_2_JavaScript概览">chapter 2 JavaScript概览</h3><h4 id="介绍">介绍</h4><p>  js是基于原型,面向对象， 弱类型的的动态脚本语言。</p>
<h4 id="Javascript基础">Javascript基础</h4><ul>
<li><p>类型：</p>
<ul>
<li>基本类型包括number, boolean, string, null 及 undefined</li>
<li><p>复杂类型包括array, function 及 object</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="number">5</span>;</span><br><span class="line">b = a;</span><br><span class="line">a; <span class="comment">// =&gt; 5</span></span><br><span class="line">b; <span class="comment">//=&gt; 6</span></span><br><span class="line"><span class="keyword">var</span> a = [<span class="string">'hello'</span>, <span class="string">'world'</span>, <span class="number">1</span>]; <span class="comment">//array</span></span><br><span class="line"><span class="keyword">var</span> b = a;</span><br><span class="line">b[<span class="number">0</span>] = <span class="string">'bye'</span>;</span><br><span class="line">a[<span class="number">0</span>]; <span class="comment">//=&gt; 'bye'</span></span><br><span class="line">b[<span class="number">0</span>]; <span class="comment">//= &gt;'bye'</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>类型的困惑(在js中判断变量值的类型并非易事)<br>你可以用两种方式来创建字符串</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'woot'</span>;</span><br><span class="line"><span class="keyword">var</span> b = <span class="keyword">new</span> <span class="built_in">String</span>(<span class="string">'woot'</span>)</span><br><span class="line">a + b; <span class="comment">//=&gt; 'woot woot'</span></span><br><span class="line"><span class="comment">//要对这两个变量使用typeof和instanceof操作符，things go fun.</span></span><br><span class="line"><span class="keyword">typeof</span> a; <span class="comment">//'string'</span></span><br><span class="line"><span class="keyword">typeof</span> b; <span class="comment">//'object'</span></span><br><span class="line">a <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">String</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//事实上， 这两个变量值绝对都是字符串</span></span><br><span class="line">a.substr == b.substr; <span class="comment">//true</span></span><br><span class="line">a == b; <span class="comment">//true</span></span><br><span class="line">a === b; <span class="comment">//false 考虑类型是否相同了</span></span><br><span class="line"><span class="comment">//考虑有此差异，建议通过直观方式进行定义，避免使用new</span></span><br><span class="line"><span class="comment">//特定值会被判定为false： null, undefined, ' ', 0</span></span><br><span class="line"><span class="keyword">var</span> a = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span>(a)&#123;</span><br><span class="line"><span class="comment">//will not execute</span></span><br><span class="line">&#125;</span><br><span class="line">a == <span class="literal">false</span>; <span class="comment">//true</span></span><br><span class="line">a === <span class="literal">false</span>; <span class="comment">//false</span></span><br><span class="line"><span class="comment">//值得注意的是：</span></span><br><span class="line"><span class="keyword">typeof</span> <span class="literal">null</span> == <span class="string">'object'</span>; <span class="comment">//很不幸，结果为true</span></span><br><span class="line"><span class="comment">//数组也不例外</span></span><br><span class="line"><span class="keyword">typeof</span> [] == <span class="string">'object'</span>; <span class="comment">// true;</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
</ul>
<ul>
<li>函数<br>  javascript 中函数最重要。它们都属于一等函数：可以作为引用存储在变量中，随后可以像其他对象一样，进行传递：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"><span class="built_in">console</span>.log(a); <span class="comment">//将函数作为参数传递</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>Javascript 中所有的函数都可以进行命名。有一点很重要，就是要区分函数名和变量名。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">a</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="string">'function'</span> == <span class="keyword">typeof</span> a; <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>THIS, FUNCTION#CALL, FUNCTION#APPLY<br>下面代码中函数被调用时， this的值是全局对象。在浏览器中，就是window对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">window</span> == <span class="keyword">this</span>; <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line">a();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>调用以下函数时，使用.call 和.apply 方法可以改变this值：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.a == <span class="string">'b'</span>; <span class="comment">// true</span></span><br><span class="line">&#125;</span><br><span class="line">a.call(&#123;a: <span class="string">'b'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>call 和 apply 区别在于 call 接受参数列表， 而apply接受一个参数数组<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params">b, c</span>)</span>&#123;</span><br><span class="line">  b == <span class="string">'first'</span>; <span class="comment">//true;</span></span><br><span class="line">  c == <span class="string">'second'</span>; <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line">a.call(&#123;a: <span class="string">'b'</span>&#125;, <span class="string">'first'</span>, <span class="string">'second'</span>);</span><br><span class="line">a.apply(&#123;a: <span class="string">'b'</span>&#125;, [<span class="string">'first'</span>, <span class="string">'second'</span>]);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>函数的参数数量<br>函数有一个很有意思的属性—参数数量， 该属性指明函数声明时可接受的参数数量。在javascript中，该属性名叫length。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span>(<span class="params">a, b, c</span>);</span><br><span class="line"><span class="title">a</span>.<span class="title">length</span> == 3; //<span class="title">true</span></span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>尽管者在浏览器端很少使用， 但是， 他对我们非常重要， 因为一些流行的node框架通过此属性来根据不同的参数个数提供不同功能的。</p>
<ul>
<li>闭包<br>在javascript中， 每次函数调用时， 新的作用域就会产生。<br>在某个作用域中定义的变量只能在该作用域或其内部的作用域（该作用域中定义的作用域）中才能访问到：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">woot</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  a == <span class="number">5</span>; <span class="comment">//false;</span></span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">6</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">test</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    a == <span class="number">6</span>; <span class="comment">//true</span></span><br><span class="line">  &#125;;</span><br><span class="line">  test();</span><br><span class="line">&#125;;</span><br><span class="line">woot();</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>自执行函数是一种机制， 通过者中机制声明和调用一个匿名函数， 能够达到仅定义一个新作用域的作用。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">3</span>;</span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;<span class="keyword">var</span> a = <span class="number">5</span>;&#125;)();</span><br><span class="line">a == <span class="number">3</span>; <span class="comment">//true;</span></span><br></pre></td></tr></table></figure></p>
<p>自执行函数对声明私有变量很有用的， 这样可以让私有变量不被其他代码所访问。</p>
<ul>
<li>类<br>javascript中没有class关键词， 类只能通过函数来定义：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>要给所有的Animal的实例定义函数， 可以通过prototype属性来完成：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Animal.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>)</span>&#123;</span><br><span class="line">  <span class="comment">//eat method</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这里值得一提的时， 在prototype的函数内部， this并非像普通函数那样指向global对象， 而是指向通过该创建的实例对象：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line">Animal.prototype.getName()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal(<span class="string">'tobi'</span>);</span><br><span class="line">a.getName == <span class="string">'tobi'</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure></p>
<ul>
<li>继承<br>javascript有基于原型的继承的特定。通常，你可以通过以下方式来模拟类型继承。<br>定义一个要继承自Animal的构造器。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ferret</span>(<span class="params"></span>)</span>&#123;&#125;;</span><br><span class="line"><span class="comment">//要定义继承链， 首先创建一个Animal对象， 然后将其赋值给ferret.prototype.</span></span><br><span class="line"><span class="comment">//实现继承</span></span><br><span class="line">Ferret.prototype = <span class="keyword">new</span> Animal();</span><br><span class="line"><span class="comment">//随后可以为子类定义属性和方法：</span></span><br><span class="line">Ferret.prototype.type = <span class="string">'domestic'</span>;</span><br><span class="line"><span class="comment">//还可以通过prototype来重写和调用父类函数</span></span><br><span class="line">Ferret.prototype.eat = <span class="function"><span class="keyword">function</span>(<span class="params">food</span>)</span>&#123;</span><br><span class="line">  Animal.prototype.eat.call(<span class="keyword">this</span>, foot);<span class="comment">//调用父类函数</span></span><br><span class="line">  <span class="comment">//ferrte特有的逻辑写在这里</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<blockquote>
<p>慕课网<br><img src="http://upload-images.jianshu.io/upload_images/891491-b095e4c9e1d0083f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="92C8DD3E-A2FC-418C-9DDB-C8ED9C8C4022.png"></p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> animal = <span class="keyword">new</span> Animal();</span><br><span class="line">animal <span class="keyword">instanceof</span> Animal <span class="comment">//true</span></span><br><span class="line">animal <span class="keyword">instanceof</span> Ferret; <span class="comment">// false</span></span><br><span class="line"><span class="keyword">var</span> ferret = <span class="keyword">new</span> Ferret();</span><br><span class="line">ferret <span class="keyword">instanceof</span> Animal; <span class="comment">//true</span></span><br><span class="line">ferret <span class="keyword">instanceof</span> Ferret; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
<p>这项技术是同类方案中最好的， 不会改变instanceof操作符的结果。</p>
<p>它的不足： 声明继承的时候创建的对象总要进行初始化(Ferret.prototype=new Animal),这种方式不好。一种解决办法就是在构造器中添加判断条件：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">a</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">if</span>(<span class="literal">false</span> !== a) <span class="keyword">return</span>;</span><br><span class="line">  <span class="comment">//初始化</span></span><br><span class="line">&#125;</span><br><span class="line">Ferret.prototype = <span class="keyword">new</span> Animal(<span class="literal">false</span>);</span><br></pre></td></tr></table></figure></p>
<p>另外一个办法就是在定义一个新的空的构造器， 并重写它的原型：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"> <span class="comment">//constructor stuff</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">f.prototype = Animal.prototype;</span><br><span class="line">Ferret.prototype = <span class="keyword">new</span> f;</span><br></pre></td></tr></table></figure></p>
<p>v8 提供了更为简洁的解决方案</p>
<ul>
<li>TRY{} CATCH{}<br>try/catch 允许进行异常捕获。下述代码会抛出异常<blockquote>
<p>var a = 5;<br>a[]<br>当函数抛出错误时， 代码就停止执行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'hi'</span>);</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'hi'</span>); <span class="comment">//这里永远不会被执行到</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</blockquote>
</li>
</ul>
<p>若使用try/catch则可以进行错误处理， 并让代码继续执行下去：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    a[];</span><br><span class="line">&#125;<span class="keyword">catch</span>(e)&#123;</span><br><span class="line">    e <span class="keyword">instanceof</span> <span class="built_in">Error</span>; <span class="comment">//true</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'you get here!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<ul>
<li><p>v8中的javascript</p>
<p>-OBJECT#KEYS<br>要想获取下述对象的键值(a and c):</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;a: <span class="string">'b'</span>, c: <span class="string">'d'</span>&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>通常会使用如下迭代方式：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a) &#123;&#125;</span><br></pre></td></tr></table></figure></p>
<p>通过对键值进行迭代， 可以将它们收集到一个数组中。不过， 如果采用如下方式对prototype进行扩展：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">object.prototype.c = <span class="string">'d'</span>;</span><br></pre></td></tr></table></figure></p>
<p>为了避免迭代中获取c可以用hasOwnProperty来进行检查<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i <span class="keyword">in</span> a)&#123;</span><br><span class="line">    <span class="keyword">if</span>(a.hasOwnProperty(i))&#123;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在v8中， 要获取对象的自由键， 还有更简单的方法：<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123;a: <span class="string">'b'</span>, c: <span class="string">'d'</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.keys(a);</span><br></pre></td></tr></table></figure></p>
<ul>
<li>ARRAY#ISARRAY<br>对数组使用typeof操作符会返回object， 然而大部分情况下， 我们要检查数组是否真的是数组。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.isArray(<span class="keyword">new</span> <span class="built_in">Array</span>) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray([]) <span class="comment">//true</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="literal">null</span>) <span class="comment">//false</span></span><br><span class="line"><span class="built_in">Array</span>.isArray(<span class="built_in">arguments</span>) <span class="comment">//false</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<ul>
<li><p>数组方法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//要遍历数组， 可以使用forEach($.each（jquery中）)</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].forEach(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(v);</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">//要过滤数组中的元素</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].filter(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &lt; <span class="number">3</span>;</span><br><span class="line">&#125;)；</span><br><span class="line"><span class="comment">//要改变数组中每个元素的值，可以使用map</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>,<span class="number">3</span> ].map(<span class="function"><span class="keyword">function</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v * <span class="number">2</span>;</span><br><span class="line">&#125;); <span class="comment">//[2, 4, 6]</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>字符串方法<br>要移除字符串首末的空格， 可以使用：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'  hello '</span>.trim();</span><br></pre></td></tr></table></figure>
</li>
<li><p>JSON<br>v8 提供了JSON.stringfy 和JSON.parse的方法来对JSON数据进行解码和编码</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(<span class="string">'&#123;"a": "b"&#125;'</span>);</span><br><span class="line">obj.a == <span class="string">'b'</span>; <span class="comment">//true</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>FUNCTION#BIND<br>.bind 允许改变this的引用</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">a</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.hello == <span class="string">"world"</span>; <span class="comment">//true</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> b = a.bind(&#123;hello, <span class="string">"world"</span>&#125;);</span><br><span class="line">b();</span><br></pre></td></tr></table></figure>
</li>
<li><p>FUNCTION#NAME<br>V8还支持非标准的函数属性名：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="function"><span class="keyword">function</span> <span class="title">woot</span>(<span class="params"></span>) </span>&#123;&#125;;</span><br><span class="line">a.name == <span class="string">"woot"</span>; <span class="comment">//true</span></span><br><span class="line"><span class="comment">//该属性用于v8内部的堆栈追踪。当错误抛出时， v8会显示一个堆栈追踪的信息， 会告诉你是哪个函数用导致了错误的发生。</span></span><br><span class="line"><span class="keyword">var</span> woot = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();&#125;;</span><br><span class="line">woot();</span><br><span class="line"><span class="comment">//Error:</span></span><br><span class="line">  <span class="comment">// at [object context]: 1:32</span></span><br><span class="line"><span class="comment">//v8无法为函数的引用指派名字。然而，如果对函数进行了命名，v8就能在堆栈追踪中将函数名显示出来：</span></span><br><span class="line">   <span class="keyword">var</span> woot = <span class="function"><span class="keyword">function</span> <span class="title">buggy</span>(<span class="params"></span>)</span>&#123;<span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();&#125;</span><br><span class="line">  woot();</span><br><span class="line"><span class="comment">//Error</span></span><br><span class="line">  <span class="comment">//at buggy ([object context]: 1: 34)</span></span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>PROTO</strong>(继承)<br>“<strong>proto</strong>“使得定义继承链变得更加容易</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Ferret</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">Ferret.prototype.__proto__ = Animal.prototype;</span><br><span class="line"><span class="comment">//这是一个非常有用的特性：</span></span><br><span class="line"> <span class="comment">//免去如下工作： 1.借助中间构造器， 2， 借助OOP工具类库。</span></span><br></pre></td></tr></table></figure>
</li>
<li><p>存取器<br>你可以通过调用方法来定义属性， 访问属性就使用<strong>defineGetter</strong>, 设置属性就使用<strong>defineSetter</strong>.<br>比如, 为Date对象定义一个ago属性， 返回以自然语言描述的日期间隔。<br>很多时候， 特别在软件中， 想用自然语言来描述日期距离某个特定时间点的时间间隔。比如： “某事件发生在三秒前”， 这种表达，要远比“某件事情发生在x年x月x日”， 这种表达更容易理解。</p>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//基于John的prettyDate</span></span><br><span class="line"><span class="built_in">Date</span>.prototype.__defineGetter___(<span class="string">'ago'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> diff = (<span class="keyword">new</span> <span class="built_in">Date</span>()).getTime() - <span class="keyword">this</span>.getTime()) / <span class="number">1000</span>)</span><br><span class="line">  <span class="keyword">var</span> day_diff = <span class="built_in">Math</span>.floor(diff / <span class="number">86400</span>);</span><br><span class="line">  <span class="keyword">return</span> day_diff == <span class="number">0</span> &amp;&amp; (diff &lt; <span class="number">60</span> &amp;&amp; <span class="string">"just now"</span> ||</span><br><span class="line">diff &lt; <span class="number">120</span> &amp;&amp; <span class="string">"1 minute ago"</span> ||</span><br><span class="line">diff &lt; <span class="number">3600</span> &amp;&amp; <span class="built_in">Math</span>.floor(diff/<span class="number">60</span>) + <span class="string">"minutes ago"</span> ||</span><br><span class="line">diff&lt;<span class="number">7200</span> &amp;&amp; <span class="string">"1 hour ago"</span>||</span><br><span class="line">diff &lt; <span class="number">86400</span> &amp;&amp; <span class="built_in">Math</span>.floor((diff/<span class="number">3600</span>) + <span class="string">"hours ago"</span>) ||</span><br><span class="line">day_diff == <span class="number">1</span> &amp;&amp; <span class="string">"Yesterday"</span>||</span><br><span class="line">day_diff &lt; <span class="number">7</span> &amp;&amp; <span class="string">"day_diff"</span> + <span class="string">" days ago"</span>||</span><br><span class="line"><span class="built_in">Math</span>.ceil(day_diff/ <span class="number">7</span> + <span class="string">"weeks ago"</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>然后简单的访问ago属性即可</p>
<p>var a = new Date(‘09/18/1991’);<br>a.ago;</p>

      
    </div>
    
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2015/09/25/阻塞与非阻塞IO/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption"><</strong>
      <div class="article-nav-title">
        
          阻塞与非阻塞IO
        
      </div>
    </a>
  
  
    <a href="/2015/09/15/算法导论-1/" id="article-nav-older" class="article-nav-link-wrap">
      <div class="article-nav-title">算法导论-1</div>
      <strong class="article-nav-caption">></strong>
    </a>
  
</nav>

  
</article>


<div class="share">
	<!-- JiaThis Button BEGIN -->
	<div class="jiathis_style">
		<span class="jiathis_txt">分享到：</span>
		<a class="jiathis_button_tsina"></a>
		<a class="jiathis_button_cqq"></a>
		<a class="jiathis_button_douban"></a>
		<a class="jiathis_button_weixin"></a>
		<a class="jiathis_button_tumblr"></a>
		<a href="http://www.jiathis.com/share" class="jiathis jiathis_txt jtico jtico_jiathis" target="_blank"></a>
	</div>
	<script type="text/javascript" src="http://v3.jiathis.com/code/jia.js?uid=1405949716054953" charset="utf-8"></script>
	<!-- JiaThis Button END -->
</div>



<div class="duoshuo">
	<!-- 多说评论框 start -->
	<div class="ds-thread" data-thread-key="了不起的node.js学习笔记" data-title="了不起的node.js学习笔记" data-url="http://yoursite.com/2015/09/24/了不起的node.js学习笔记/"></div>
	<!-- 多说评论框 end -->
	<!-- 多说公共JS代码 start (一个网页只需插入一次) -->
	<script type="text/javascript">
	var duoshuoQuery = {short_name:"true"};
	(function() {
		var ds = document.createElement('script');
		ds.type = 'text/javascript';ds.async = true;
		ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
		ds.charset = 'UTF-8';
		(document.getElementsByTagName('head')[0] 
		 || document.getElementsByTagName('body')[0]).appendChild(ds);
	})();
	</script>
	<!-- 多说公共JS代码 end -->
</div>




</div>
      <footer id="footer">
  <div class="outer">
    <div id="footer-info">
    	<div class="footer-left">
    		&copy; 2016 libchaos
    	</div>
    </div>
  </div>
</footer>

    </div>
    
  </div>
</body>
</html>